{
  "notes": [
    {
      "id": "1",
      "title": "微積分學習筆記 - 極限與連續",
      "category": "數學",
      "tags": [
        "微積分",
        "極限",
        "連續"
      ],
      "date": "2024-11-05",
      "readTime": "8 分鐘",
      "imageUrl": "/attached_assets/generated_images/Math_notes_image_aaa165c2.png",
      "content": "# 前言\n\n極限是微積分的基礎概念，理解極限對於後續學習導數和積分至關重要。本篇筆記將詳細介紹極限的定義、性質以及連續函數的概念。\n\n## 極限的定義\n\n函數 f(x) 在 x 趨近於 a 時的極限為 L，記作：\n\nlim(x→a) f(x) = L\n\n這表示當 x 無限接近 a（但不等於 a）時，f(x) 的值會無限接近 L。\n\n### 重要性質\n\n1. **唯一性**：如果極限存在，則極限值是唯一的\n2. **局部有界性**：如果極限存在，則函數在該點附近必定有界\n3. **保號性**：如果極限大於零，則函數在該點附近的值也大於零\n\n## 極限的運算法則\n\n假設 lim(x→a) f(x) = A，lim(x→a) g(x) = B，則：\n\n- **和的極限**：lim(x→a) [f(x) + g(x)] = A + B\n- **積的極限**：lim(x→a) [f(x) × g(x)] = A × B\n- **商的極限**：lim(x→a) [f(x) / g(x)] = A / B（B ≠ 0）\n\n## 連續函數\n\n如果函數 f(x) 在點 a 處連續，必須滿足三個條件：\n\n1. f(a) 有定義\n2. lim(x→a) f(x) 存在\n3. lim(x→a) f(x) = f(a)\n\n### 連續函數的性質\n\n- 連續函數的和、差、積、商（分母不為零）仍為連續函數\n- 連續函數的複合函數仍為連續函數\n- 初等函數在其定義域內都是連續的\n\n## 實用技巧\n\n計算極限時常用的方法：\n\n1. **直接代入法**：當函數連續時，直接將 x = a 代入\n2. **因式分解**：處理 0/0 型不定式\n3. **有理化**：處理根式極限\n4. **洛必達法則**：處理不定式（進階）\n\n## 總結\n\n極限和連續是微積分的基石。掌握這些概念不僅有助於理解導數和積分，也能培養嚴謹的數學思維。建議多做練習題來鞏固理解。\n",
      "slug": "微積分學習筆記-極限與連續"
    },
    {
      "id": "2",
      "title": "JavaScript ES6+ 新特性整理",
      "category": "程式設計",
      "tags": [
        "JavaScript",
        "ES6",
        "前端"
      ],
      "date": "2024-11-03",
      "readTime": "12 分鐘",
      "imageUrl": "/attached_assets/generated_images/Programming_notes_image_071eb3a1.png",
      "content": "# 前言\n\nES6（ECMAScript 2015）為 JavaScript 帶來了許多強大的新特性，讓程式碼更簡潔、易讀且易於維護。本篇整理了最常用的 ES6+ 特性。\n\n## 變數宣告：let 和 const\n\n```javascript\n// const：宣告常數，不可重新賦值\nconst PI = 3.14159;\n\n// let：區塊作用域的變數\nlet count = 0;\ncount = 1; // 可以重新賦值\n```\n\n## 箭頭函數\n\n箭頭函數提供了更簡潔的函數寫法：\n\n```javascript\n// 傳統函數\nfunction add(a, b) {\n  return a + b;\n}\n\n// 箭頭函數\nconst add = (a, b) => a + b;\n```\n\n## 解構賦值\n\n快速從物件或陣列中提取值：\n\n```javascript\n// 物件解構\nconst user = { name: '小明', age: 20 };\nconst { name, age } = user;\n\n// 陣列解構\nconst [first, second] = [1, 2, 3];\n```\n\n## 展開運算子\n\n```javascript\n// 陣列展開\nconst arr1 = [1, 2, 3];\nconst arr2 = [...arr1, 4, 5];\n\n// 物件展開\nconst obj1 = { a: 1, b: 2 };\nconst obj2 = { ...obj1, c: 3 };\n```\n\n## Promise 和 async/await\n\n處理非同步操作的現代方式：\n\n```javascript\n// Promise\nfetch('/api/data')\n  .then(response => response.json())\n  .then(data => console.log(data));\n\n// async/await\nasync function fetchData() {\n  const response = await fetch('/api/data');\n  const data = await response.json();\n  return data;\n}\n```\n\n## 總結\n\nES6+ 的新特性大大提升了 JavaScript 的開發體驗。建議在實際專案中多加練習這些特性，讓程式碼更加優雅且易於維護。\n",
      "slug": "JavaScript-ES6-新特性整理"
    }
  ]
}